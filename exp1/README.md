# RISC-V 内核课程实践 实验报告一  
## RISC-V 引导与裸机启动  


## 一、实验概述  
### 1.1 实验目标  
参考 xv6 操作系统启动机制，理解并实现 RISC-V 架构下最小操作系统的引导流程，最终在 QEMU 模拟器中输出 "Hello OS"，掌握裸机启动核心环节（汇编启动、链接脚本、串口驱动）。  

### 1.2 核心知识点  
- RISC-V 机器模式启动流程与栈初始化  
- 链接脚本对内存布局的定义（代码段、数据段、BSS 段、栈）  
- UART 16550 串口驱动的最小实现（轮询式字符发送）  
- QEMU virt 平台的内存映射与设备地址  


## 二、实验环境  
| 工具/环境         | 版本/说明                          | 用途                          |
|--------------------|-----------------------------------|-------------------------------|
| RISC-V 交叉工具链  | `riscv64-unknown-elf-gcc 10.2+`   | 编译 RISC-V 架构代码          |
| QEMU 模拟器        | `qemu-system-riscv64 6.0+`        | 模拟 RISC-V virt 硬件平台     |


## 三、实验任务与实现过程  
### 任务1：理解 xv6 启动流程  
#### 1.1 核心文件关键问题解答  
通过分析 xv6 的 `kernel/entry.S`、`kernel/kernel.ld`、`kernel/uart.c`，明确裸机启动的核心逻辑：  

| 问题                          | 解答                                                                 |
|-------------------------------|----------------------------------------------------------------------|
| 为什么第一条指令是设置栈指针？ | RISC-V 函数调用依赖栈保存返回地址（`ra` 寄存器）和局部变量，无栈则无法跳转到 C 代码。 |
| 为什么要清零 BSS 段？         | BSS 段存储未初始化的全局/静态变量，C 标准要求其初始值为 0，需手动清零。 |
| `ENTRY(_entry)` 的作用是什么？ | 告诉链接器内核入口地址为 `_entry`（汇编启动代码的起始标签）。         |
| 代码段为何放在 `0x80000000`？ | QEMU virt 平台约定内核加载地址为 `0x80000000`（低地址为固件/设备地址）。 |

#### 1.2 简化方向  
- **多核简化**：仅支持单核，无需 xv6 中多核启动的 `hartid` 检测与核间同步。  
- **内存管理简化**：无需页表/虚拟内存，直接使用物理地址访问设备与内存。  


### 任务2：设计最小启动流程  
#### 2.1 启动流程图  
```mermaid
graph TD
    A[QEMU 加载内核到 0x80000000] --> B[执行汇编入口 _start]
    B --> C[UART 输出 'S' 验证硬件可访问]
    C --> D[初始化栈指针 sp = stack_top]
    D --> E[UART 输出 'P' 确认栈就绪]
    E --> F[清零 BSS 段（__edata 到 __end）]
    F --> G[调用 C 函数 kernel_main]
    G --> H[初始化 UART]
    H --> I[UART 输出 "Hello OS"]
    I --> J[死循环防止程序退出]
```

#### 2.2 内存布局方案  
基于链接脚本定义，内存按「代码段→只读数据段→数据段→BSS 段→栈」顺序排列，关键地址规划如下：  
| 内存区域       | 地址范围          | 用途                          | 关键符号               |
|----------------|-------------------|-------------------------------|------------------------|
| 代码段 .text   | 0x80000000 ~ etext | 汇编入口、C 函数指令          | _start、etext          |
| 数据段 .data   | etext ~ __edata   | 已初始化全局变量              | __edata                |
| BSS 段 .bss    | __edata ~ __end   | 未初始化全局变量              | __end                  |
| 栈             | stack_top（0x80010000）向下生长 | 函数调用栈                    | stack_top              |

#### 2.3 必需硬件初始化步骤  
1. **UART 初始化**：读 LSR 寄存器清除初始状态（QEMU 下默认波特率 115200/8N1，无需额外配置）。  
2. **栈初始化**：设置栈顶地址为 `0x80010000`（大小 64KB，满足裸机函数调用需求）。  
3. **BSS 清零**：遍历 `__edata` 到 `__end` 地址，将内存填充为 0。  


### 任务3：实现启动汇编代码（kernel/entry.S）  
核心功能围绕「硬件验证→栈初始化→BSS 清零→跳转 C 代码」展开：  
1. **硬件验证**：直接向 UART 基地址（`0x10000000`）写入字符 'S'，确认 UART 可访问。  
2. **栈初始化**：通过 `la sp, stack_top` 加载链接脚本定义的栈顶地址，后输出 'P' 标记栈就绪。  
3. **BSS 清零**：用循环遍历 `__edata` 到 `__end` 地址，每次写入 8 字节（RV64 对齐）的 0。  
4. **跳转 C 代码**：通过 `call kernel_main` 调用 C 主函数，若返回则进入死循环 `hang`。  


### 任务4：编写链接脚本（kernel/linker.ld）  
链接脚本的核心是定义内存布局与关键符号，供汇编和 C 代码访问：  
1. **入口与起始地址**：`ENTRY(_start)` 指定内核入口为 `_start`，`. = 0x80000000` 对齐 QEMU 加载地址。  
2. **段组织**：按「代码段→只读数据段→数据段→BSS 段」顺序排列，确保各段地址连续且对齐（如 4KB/16 字节对齐）。  
3. **符号定义**：通过 `PROVIDE` 定义 `etext`（代码段结束）、`__edata`（数据段结束）、`__end`（BSS 段结束）、`stack_top`（栈顶）。  

编译后通过 `riscv64-unknown-elf-objdump -h kernel.elf` 检查段地址，通过 `nm` 命令验证关键符号是否正确定义。  


### 任务5：实现串口驱动（kernel/uart.c）  
基于 UART 16550 寄存器特性，实现最小化字符发送功能：  
1. **核心寄存器**：依赖 RBR/THR（偏移 0x00，发送/接收数据）和 LSR（偏移 0x05，状态检测）。  
2. **关键函数**：  
   - `uart_init()`：读 LSR 寄存器清除初始状态；  
   - `uart_putc(char c)`：轮询 LSR.THRE 位（bit5），待发送缓冲区空后写入字符；  
   - `uart_puts(const char *s)`：遍历字符串调用 `uart_putc`，遇到 `\n` 补 `\r` 适配终端换行。  


### 任务6：完成 C 主函数（kernel/main.c）  
逻辑简洁，仅包含「初始化→输出→死循环」三步：  
1. 调用 `uart_init()` 初始化 UART；  
2. 调用 `uart_puts("Hello OS\n")` 输出目标字符串；  
3. 进入 `while (1)` 死循环，防止程序退出导致 QEMU 重启。  


### 任务7：编译与运行验证  
#### 7.1 编译命令  
通过 Makefile 自动化编译，核心命令如下：  
```bash
# 编译生成内核镜像 kernel.elf
make all
# 调用 QEMU 运行内核
make run
# 分析内核段与符号（可选）
make dump
```

#### 7.2 运行结果  
执行 `make run` 后，QEMU 终端输出如下，实验目标达成：  
```
Running bare-metal kernel (no OpenSBI) ...
SP
Hello OS
```
（注：`S` 为汇编早期硬件验证输出，`P` 为栈初始化完成标记，后续为 "Hello OS" 目标输出）


## 四、实验总结  
### 4.1 实验收获  
1. 掌握了 RISC-V 裸机启动的完整流程：从汇编入口初始化硬件，到跳转 C 代码实现业务逻辑。  
2. 理解了链接脚本对内存布局的控制作用，以及 BSS 段清零、栈初始化的必要性。  
3. 学会了 UART 16550 串口的最小化实现，掌握轮询式 I/O 的核心逻辑（状态检测→数据传输）。  

### 4.2 问题与解决  
1. **QEMU 无输出**：排查发现 UART 基地址错误，修正为 `0x10000000` 后正常输出。  
2. **BSS 段未清零**：汇编循环中地址递增步长错误（初始为 4 字节，修正为 8 字节适配 RV64）。  
