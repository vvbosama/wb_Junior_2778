# RISC-V 内核课程实践 实验报告二  
## 内核 printf 与清屏功能实现  


## 一、实验概述  
### 1.1 实验目标  
深入分析 xv6 输出系统架构，理解格式化字符串处理原理与分层设计思想，独立实现功能完整的内核 `printf`（支持多格式输出）与清屏/光标控制功能，掌握 C 语言可变参数、ANSI 转义序列、设备抽象分层的核心技术。  

### 1.2 核心知识点  
- xv6 输出系统的“格式化层→控制台层→硬件层”分层架构  
- C 语言可变参数（`stdarg.h` 的 `va_start`/`va_arg`/`va_end` 宏）  
- 数字转字符串算法（十进制/十六进制、正负号处理、边界值如 `INT_MIN`）  
- ANSI 转义序列（清屏、光标定位）  
- 串口驱动与控制台抽象的接口设计  


## 二、实验任务与实现过程  
### 任务1：深入理解 xv6 输出架构  
#### 1.1 xv6 输出系统核心函数分析  
通过研读 xv6 的 `printf.c`/`uart.c`/`console.c`，明确各模块功能：  
- **`printf.c`**：负责格式化字符串解析，支持 `%d`（十进制）、`%x`（十六进制）、`%s`（字符串）、`%c`（字符）等格式，通过可变参数宏提取输入参数，调用 `consputc` 输出字符。  
- **`console.c`**：控制台抽象层，提供 `consputc`/`consolewrite` 接口，屏蔽底层硬件差异（如 UART/屏幕），统一向上层提供输出能力。  
- **`uart.c`**：硬件驱动层，实现 `uartputc`/`uartinit`，直接操作 UART 寄存器完成字符发送，是输出的“最终执行层”。  

#### 1.2 xv6 分层架构与优势  
xv6 输出架构遵循“**格式化层→控制台层→硬件层**”的调用链（`printf() → consputc() → uartputc() → 硬件寄存器`），各层职责与优势如下：  

| 层级       | 核心职责                          | 设计优势                          |
|------------|-----------------------------------|-----------------------------------|
| 格式化层   | 解析格式字符串、处理可变参数      | 上层无需关注格式细节，接口统一（如 `printf` 可直接调用） |
| 控制台层   | 统一输出接口，屏蔽硬件差异        | 若后续替换硬件（如从 UART 改为 VGA），仅需修改该层，上层代码无需变动 |
| 硬件层     | 直接操作硬件寄存器，实现字符发送  | 专注硬件交互，逻辑简洁，便于调试与维护 |

#### 1.3 关键问题思考  
- **为什么不使用递归进行数字转换？**  
  递归会占用栈空间，裸机内核栈大小有限（如 64KB），递归深度过大可能导致栈溢出；而迭代（循环）方式仅需固定大小的字符数组（如 32 字节），更适合裸机环境。  
- **`printint` 如何处理 `INT_MIN`？**  
  `INT_MIN`（-2147483648）的绝对值超出 `int` 最大值（2147483647），直接取反会溢出。xv6 采用“`unsigned long long` 类型转换”技巧：将 `INT_MIN` 转为无符号数（`(unsigned long long)(-(x+1)) + 1ULL`），避免溢出问题。  


### 任务2：设计输出系统架构  
#### 2.1 自定义输出系统架构（文字版）  
参考 xv6 分层思想，简化并优化设计，架构分为三层，调用链为：`printf() → console_* → uart_*`，各层接口与功能如下：  

| 层级       | 核心接口                          | 功能描述                          |
|------------|-----------------------------------|-----------------------------------|
| 格式化层   | `int printf(const char *fmt, ...)`<br>`void printfint(int x)` | 解析格式字符串，处理 `%d`/`%x`/`%s` 等格式；`printfint` 专注十进制数字输出 |
| 控制台层   | `void console_putc(char c)`<br>`void console_puts(const char *s)`<br>`void clear_screen(void)`<br>`void goto_xy(int x, int y)` | 向上层提供字符/字符串输出接口；实现清屏、光标定位等控制台控制功能 |
| 硬件层     | `void uart_putc(char c)`<br>`void uart_puts(const char *s)`<br>`void uart_init(void)` | 初始化 UART 设备，实现字符/字符串的硬件发送；向下对接 UART 寄存器 |

#### 2.2 与 xv6 设计的异同  
- **相同点**：均采用三层分层架构，屏蔽硬件差异，统一输出接口；数字转换使用迭代方式，避免栈溢出。  
- **不同点**：  
  1. 简化控制台层功能：仅保留核心输出与控制接口（清屏、光标定位），无需 xv6 复杂的中断处理；  
  2. 扩展 `printf` 支持：新增 `%p`（指针地址，十六进制带 `0x` 前缀）格式，适配裸机调试需求；  
  3. 错误处理优化：对 `NULL` 字符串输入，输出 `(null)` 而非直接崩溃，增强鲁棒性。  

#### 2.3 关键设计决策  
- **是否需要缓冲区？**  
  本实验暂不添加缓冲区：裸机内核输出场景以“调试信息”为主，单次输出数据量小；轮询式 UART 发送已满足需求，添加缓冲区会增加代码复杂度（需处理缓冲区满/空逻辑）。  
- **如何处理格式错误？**  
  遇到未知格式符（如 `%z`）时，原样输出 `%` 和格式符（如 `%z`），避免程序崩溃，便于调试格式错误。  


### 任务3：实现数字转换核心算法  
#### 3.1 核心思路  
数字转换的核心是“**迭代取余→字符存储→逆序输出**”，需解决三个关键问题：正负号处理、进制转换、边界值（`INT_MIN`/`LLONG_MIN`）兼容。  

#### 3.2 关键步骤实现  
1. **类型转换与边界处理**：  
   用 `unsigned long long` 存储待转换数字，避免 `INT_MIN` 取反溢出——对负数 `x`，计算 `ux = (unsigned long long)(-(x+1)) + 1ULL`，将其转为无符号数后处理。  
2. **迭代取余与字符存储**：  
   定义字符数组 `buf[32]`（足够存储 64 位数字的最大长度），循环对 `ux` 取余（如十进制取余 10，十六进制取余 16），将余数映射为字符（通过 `digits = "0123456789abcdef"` 数组），存入 `buf`。  
3. **逆序输出**：  
   数字取余得到的字符是“低位在前”，需从数组末尾向前遍历，调用 `console_putc` 输出，得到正确的数字顺序。  

#### 3.3 调试策略  
按“**十进制正数→十进制负数→十六进制**”顺序调试：  
1. 先测试 `printf("%d", 42)`，确认输出 `42`；  
2. 再测试 `printf("%d", -123)` 和 `printf("%d", INT_MIN)`，确认负号正常显示，无溢出；  
3. 最后测试 `printf("%x", 0xABC)`，确认十六进制小写字母（`abc`）输出正确。  


### 任务4：实现格式字符串解析  
#### 4.1 可变参数处理  
通过 `stdarg.h` 宏实现可变参数提取：  
1. 用 `va_list ap` 定义参数列表指针；  
2. `va_start(ap, fmt)` 初始化指针，指向 `fmt` 后的第一个参数；  
3. 解析到格式符时，用 `va_arg(ap, 类型)` 提取对应类型参数（如 `%d` 提取 `int`，`%s` 提取 `const char *`）；  
4. 解析完成后，用 `va_end(ap)` 释放参数列表，避免内存泄漏。  

#### 4.2 格式解析逻辑  
采用“**状态机**”思路遍历格式字符串 `fmt`：  
- **普通字符**：直接调用 `console_putc` 输出；  
- **遇到 `%`**：进入格式处理状态，判断下一个字符：  
  - `%`：输出 `%`；  
  - `d`：提取 `int` 参数，调用数字转换函数输出十进制；  
  - `x`：提取 `unsigned` 参数，输出十六进制；  
  - `p`：提取 `void *` 指针，先输出 `0x`，再输出十六进制地址；  
  - `c`：提取 `int` 参数（需强转为 `char`），输出字符；  
  - `s`：提取 `const char *` 字符串，若为 `NULL` 输出 `(null)`，否则调用 `console_puts` 输出；  
  - **未知格式符**：原样输出 `%` 和格式符。  

#### 4.3 测试用例设计  
编写两类测试用例，覆盖基本功能与边界场景：  
```c
// 基本功能测试
void test_printf_basic() {
    printf("Decimal: %d\n", 42);       // 十进制正数
    printf("Negative: %d\n", -123);    // 十进制负数
    printf("Hex: 0x%x\n", 0xABC);      // 十六进制
    printf("String: %s\n", "Hello OS");// 字符串
    printf("Char: %c\n", 'X');         // 字符
    printf("Percent: %%\n");           // 百分号
    printf("Pointer: %p\n", &test_printf_basic); // 指针地址
}

// 边界场景测试
void test_printf_edge() {
    printf("INT_MAX: %d\n", 2147483647);  // 最大值
    printf("INT_MIN: %d\n", -2147483648); // 最小值（无溢出）
    printf("NULL String: %s\n", (char*)0); // NULL字符串
    printf("Empty String: %s\n", "");      // 空字符串
}
```


### 任务5：实现清屏功能  
#### 5.1 ANSI 转义序列学习  
ANSI 转义序列是终端控制的标准语法，以 `\x1b[`（即 `ESC[`）开头，核心序列如下：  
- `\x1b[2J`：清除整个屏幕；  
- `\x1b[H`：将光标移动到屏幕左上角（行 1，列 1）；  
- `\x1b[{row};{col}H`：将光标移动到指定行 `row`、列 `col`。  

#### 5.2 核心功能实现  
1. **清屏函数 `clear_screen()`**：  
   发送“清屏+光标归位”组合序列 `\x1b[2J\x1b[H`，调用 `uart_puts` 发送到终端，实现“清屏后光标回到左上角”效果。  
2. **光标定位函数 `goto_xy(int col, int row)`**：  
   动态生成 ANSI 序列 `\x1b[{row};{col}H`：  
   - 先将 `row`（行）和 `col`（列）转为字符串（迭代取余，逆序拼接）；  
   - 拼接 `\x1b[`、行号、`;`、列号、`H` 形成完整序列；  
   - 调用 `uart_puts` 发送，实现光标跳转。  

#### 5.3 扩展功能测试  
```c
void test_console_control() {
    clear_screen();                  // 清屏
    goto_xy(10, 5);                  // 光标跳转到第5行第10列
    printf("Hello at (10,5)\n");     // 在指定位置输出
}
```


### 任务6：综合测试与优化  
#### 6.1 功能测试  
1. **`printf` 格式测试**：运行 `test_printf_basic` 和 `test_printf_edge`，确认所有格式输出正确，`INT_MIN` 无溢出，`NULL` 字符串输出 `(null)`。  
2. **控制台控制测试**：运行 `test_console_control`，终端先清屏，再在第5行第10列显示文字，最后光标回到左上角，符合预期。  
3. **性能测试**：循环输出 1000 条调试信息，UART 轮询发送无丢包，终端显示完整，证明稳定性。  

#### 6.2 性能优化考虑  
1. **字符串批量发送优化**：`console_puts` 直接调用 `uart_puts`（而非逐字符调用 `uart_putc`），减少 UART 状态查询次数，提升字符串输出效率。  
2. **数字转换查表优化**：十六进制转换通过 `digits` 数组直接映射，避免条件判断（如 `if (remainder >=10) remainder + 'a' -10`），简化代码并提升速度。  


## 三、实验结果与验证  
### 4.1 编译与运行命令  
```bash
# 清除旧编译产物
make clean
# 编译内核镜像
make all
# 运行 QEMU，测试输出功能
make run
```

### 4.2 预期输出结果  
终端先清屏，随后显示以下内容（光标定位效果需在支持 ANSI 转义序列的终端中查看）：  
```
Hello at (10,5)
Decimal: 42
Negative: -123
Hex: 0xabc
String: Hello OS
Char: X
Percent: %
Pointer: 0x80000120
INT_MAX: 2147483647
INT_MIN: -2147483648
NULL String: (null)
Empty String: 
```


## 五、实验总结  
### 5.1 实验收获  
1. 掌握了分层架构设计思想：通过“格式化层→控制台层→硬件层”分离关注点，降低代码耦合度，提升可维护性；  
2. 深入理解可变参数处理：熟练使用 `stdarg.h` 宏提取不定长参数，解决 `printf` 格式解析的核心问题；  
3. 掌握 ANSI 转义序列应用：实现清屏、光标定位等控制台控制，为裸机内核调试提供更友好的交互方式；  
4. 提升边界处理能力：解决 `INT_MIN` 溢出、`NULL` 指针输入等异常场景，增强代码鲁棒性。  

### 5.2 问题与解决  
1. **`INT_MIN` 输出错误**：初始直接用 `ux = -x` 处理负数，导致 `INT_MIN` 溢出；改为 `(unsigned long long)(-(x+1)) + 1ULL` 后，问题解决。  
2. **光标定位序列无效**：忘记在 ANSI 序列末尾添加 `H`（如写成 `\x1b[5;10` 而非 `\x1b[5;10H`），补充后光标正常跳转。  
3. **`%p` 格式无 `0x` 前缀**：在数字转换前，先调用 `console_puts("0x")`，确保指针地址输出符合调试习惯。  

### 5.3 后续改进方向  
1. **添加输出缓冲区**：针对大量连续输出场景，设计环形缓冲区，减少 UART 轮询等待时间，提升输出效率；  
2. **扩展颜色输出**：利用 ANSI 转义序列（如 `\x1b[31m` 红色），实现 `printf_color` 函数，支持不同级别调试信息的颜色区分；  
3. **支持可变宽度格式**：扩展 `printf` 支持 `%5d`（右对齐，占 5 个字符宽度）、`%-5d`（左对齐），提升输出排版美观度。